# 僵尸进程和孤儿进程
## 孤儿进程
孤儿进程是父进程先于子进程执行结束退出，此时子进程会被init进程（pid=1）收养，成为init进程的子进程，和正常的进程无异，孤儿进程没有什么危害
## 僵尸进程
僵尸进程则是子进程先退出，但是此时父进程处于无限循环或者长时间处理其他任务，没有回收子进程的资源；
exit(0)只是退出进程，但不会释放进程的资源，需要父进程调用wait函数回收空间，因此僵尸进程是消耗系统资源的；
## 僵尸进程的处理
* wait/waitpid
wait是waitpid的一种特例，wait只能等待第一个结束的子进程，并且会阻塞父进程，而waitpid可以设置参数选择是否阻塞及等待的子进程
* signal函数
signal函数有两种处理方式，一种是父进程来处理，类似于事件处理机制，子进程结束时，父进程收到通知，调用wait回收；
另一种方式是内核处理，此时父进程不用关心子进程何时结束，子进程不向父进程发送通知，内核自己回收；
* 销毁父进程
此时子进程变为孤儿进程
* 两次fork，孙进程
https://blog.csdn.net/weixin_42048463/article/details/94716046
# 零拷贝技术（linux高性能服务器编程）
从磁盘读取文件到发送到网络上，数据会在外设，kernel空间和user空间频繁拷贝，以及用户态和内核态的频繁切换，增加CPU 的负担；
零拷贝技术避免CPU 进行频繁的数据拷贝工作，为了达到这个目的，一个方向就是避免数据在用户空间和内核空间来回拷贝；
## mmap函数
申请一段内存空间，将内核缓冲区与应用程序共享，减少了数据拷贝次数，但是存在内核态和用户态的切换
## sendffile
只能把数据从文件传送到socket上，反之不行；直接将内核态缓存区的数据copy到socket缓冲区，所有拷贝都在内核态进行
## splice函数
在两个文件描述符之间移动数据，利用linux管道缓冲机制，两个文件描述符中必有一个为管道，不需要在内核空间和用户空间拷贝数据
#  写时复制
有时候必须在用户空间和内核空间进行数据拷贝，此时需要使用写时复制COW技术
# tee函数
在两个管道文件描述符之间移动数据

